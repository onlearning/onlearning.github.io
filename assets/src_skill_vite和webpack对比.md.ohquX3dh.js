import{_ as o,c,a2 as d,o as a}from"./chunks/framework.DPuwY6B9.js";const b=JSON.parse('{"title":"vite 和 webpack 对比","description":"","frontmatter":{},"headers":[],"relativePath":"src/skill/vite和webpack对比.md","filePath":"src/skill/vite和webpack对比.md","lastUpdated":1714114110000}'),t={name:"src/skill/vite和webpack对比.md"};function r(p,e,s,i,l,n){return a(),c("div",null,e[0]||(e[0]=[d('<h1 id="vite-和-webpack-对比" tabindex="-1">vite 和 webpack 对比 <a class="header-anchor" href="#vite-和-webpack-对比" aria-label="Permalink to &quot;vite 和 webpack 对比&quot;">​</a></h1><h2 id="定位分析" tabindex="-1">定位分析 <a class="header-anchor" href="#定位分析" aria-label="Permalink to &quot;定位分析&quot;">​</a></h2><p>打包工具：<code>webpack</code>、<code>rollup</code>、<code>parcel</code>、<code>esbuild</code></p><p>作用：可以对代码进行压缩、合并、转换、分割、打包</p><p>衍生：<code>vue-cli</code>、<code>create-react-app</code>、<code>umi</code> 等是基于 <code>webpack</code> 的上层封装，用于快速创建项目</p><p><code>vite</code>：开发环境依赖 <code>esbuild </code>进行预构建，生产环境则依赖 <code>rollup</code> 进行打包</p><h2 id="差异分析" tabindex="-1">差异分析 <a class="header-anchor" href="#差异分析" aria-label="Permalink to &quot;差异分析&quot;">​</a></h2><h3 id="启动差异" tabindex="-1">启动差异 <a class="header-anchor" href="#启动差异" aria-label="Permalink to &quot;启动差异&quot;">​</a></h3><p><strong>webpack</strong>：<code>webpack</code> 会根据我们配置文件（<code>webpack.config.js</code>） 中的入口文件（<code>entry</code>），分析出项目项目所有依赖关系，会将所有文件编译一遍，无论模块是否被执行，项目复杂度越增加，启动时间就越长。然后打包成一个文件（<code>bundle.js</code>），交给浏览器去加载渲染。</p><p><strong>bundle.js</strong>：是可以被浏览器认识的，拿来即可直接运行的 <code>js</code> 文件。<code>bundle.js</code> 的本质是一个立即执行函数，这个函数的输入是依赖拓补图（一个 js 对象），没有输出。内部会按照依赖顺序，依次以 <code>eval(code)</code> 的形式运行代码。</p><p><strong>Vite</strong>：首先会用 <code>esbuild</code> 进行预构建，将所有模块转换为 <code>es module</code>，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行按需编译，然后返回给浏览器。</p><p><strong>es module</strong>：使用 <code>import</code> 用于导入模块， <code>export</code> 用于导出模块。模块内部的变量和函数默认是私有的，不会污染全局作用域，浏览器遇到内部的 <code>import</code> 引用时，会自动发起 <code>http</code> 请求，去加载对应的模块。</p><h3 id="底层差异" tabindex="-1">底层差异 <a class="header-anchor" href="#底层差异" aria-label="Permalink to &quot;底层差异&quot;">​</a></h3><p><strong>webpack</strong>：基于 <code>nodejs</code> 运行的，由于 <code>js</code> 只能单线程运行，无法利用多核 CPU 的优势，当项目越来越大时，构建速度也就越来越慢了。</p><p><strong>vite 基于 esbuild</strong>：基于 <code>Go</code> 语言，可以充分利用多核 CPU 的优势，它在构建依赖的速度上比使用 <code>JavaScript</code> 编写的打包器快 10-100 倍。</p><p><strong>vite 基于 http2</strong>：可以并发请求，在之前 <code>http1</code> 的时候，浏览器对同一个域名的请求，是有并发限制的，一般为 6 个，如果并发请求 6 个以上，就会造成阻塞问题，所以在 <code>http1</code> 的时代，我们要减少打包产物的文件数量，减少并发请求，来提高项目的加载速度。2015 年以后，<code>http2</code> 出现了且没有并发限制。这时候，将打包产物分成多个小模块，并行去加载。<code>vite</code> 也充分利用了这一优势，对项目资源进行了合理的拆分，访问项目时，同时加载多个模块，来提升项目访问速度。</p><h3 id="热更新效率" tabindex="-1">热更新效率 <a class="header-anchor" href="#热更新效率" aria-label="Permalink to &quot;热更新效率&quot;">​</a></h3><p><strong>webpack</strong> 项目中，每次修改文件，都会对整个项目重新进行打包，虽然 <code>webpack</code> 现在有了缓存机制，但还是无法从根本上解决这个问题。</p><p><strong>vite</strong> <code>vite</code> 项目中，监听到文件变更后，会用 <code>websocket</code> 通知浏览器，重新发起新的请求，只对该模块进行重新编译，然后进行替换。 并且基于 <code>es module</code> 的特性，<code>vite</code> 利用浏览器的缓存策略，并且做了协商缓存处理，针对依赖模块（第三方库）做了强缓存处理，所以热更新效率高。</p><h3 id="打包差异" tabindex="-1">打包差异 <a class="header-anchor" href="#打包差异" aria-label="Permalink to &quot;打包差异&quot;">​</a></h3><p><strong>Rollup</strong> 是一款 <code>ES Module</code> 打包器相比于 <code>Webpack</code>，<code>Rollup</code> 要小巧的多，打包生成的文件更小更快。<code>vite</code> 正是基于 <code>es module</code> 的特性实现的，所以使用 <code>rollup</code> 要更合适一些。</p><p><strong>vite 为什么不用 esbuild 打包</strong></p><p><code>Vite</code> 目前的插件 API 与使用 <code>esbuild</code> 作为打包器并不兼容，<code>rollup</code> 插件 api 与基础建设更加完善，生产环境 <code>vite</code> 使用 <code>rollup</code> 打包会更稳定一些。 如果后面 <code>esbuild</code> 基础建设与生态更加完善后，<code>esbuild</code> 还是更有优势的。 所以使用 <code>vite</code> 可能会带来开发环境与生产环境打包结果不一致的问题。</p><h3 id="使用差异" tabindex="-1">使用差异 <a class="header-anchor" href="#使用差异" aria-label="Permalink to &quot;使用差异&quot;">​</a></h3><p><strong>webpack</strong>：使用 <code>webpack</code> 自己去搭建项目脚手架时，需要配置比较多的东西， 比如：跨域、代码压缩、代码分割、<code>css</code> 预处理器的代码转换、样式兼容性、<code>vue/react</code> 代码解析、图片压缩、代码热更新、<code>es</code> 降级、<code>ts</code> 转换等等，我们需要了解各种 <code>loader</code>、<code>plugin</code> 的使用，并且需要根据项目场景，对配置不断进行优化 所以就出现了一些基于 <code>webpack</code> 上层封装的脚手架，如：<code>vue-cli</code>、<code>create-react-app</code>、<code>umi</code> 等。</p><p><strong>vite</strong> <code>vite</code> 对我们常用功能都做了内置，比如：<code>css</code> 预处理器、<code>html</code> 预处理器、<code>hash</code> 命名、异步加载、分包、压缩、HMR 等等，我们可以很轻松的通过配置项去配置</p><p><code>Webpack</code> 的 <code>loader</code> 和 <code>plugin</code> 已经非常成熟，社区较为丰富，但是，<code>Vite</code> 的生态还相对落后，但正在逐渐发展。</p>',27)]))}const h=o(t,[["render",r]]);export{b as __pageData,h as default};

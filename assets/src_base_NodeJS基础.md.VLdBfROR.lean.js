import{_ as a,c as p,a2 as n,o as e}from"./chunks/framework.DPuwY6B9.js";const u=JSON.parse('{"title":"Node JS 基础","description":"","frontmatter":{},"headers":[],"relativePath":"src/base/NodeJS基础.md","filePath":"src/base/NodeJS基础.md","lastUpdated":1713863841000}'),o={name:"src/base/NodeJS基础.md"};function l(c,s,r,t,d,i){return e(),p("div",null,s[0]||(s[0]=[n(`<h1 id="node-js-基础" tabindex="-1">Node JS 基础 <a class="header-anchor" href="#node-js-基础" aria-label="Permalink to &quot;Node JS 基础&quot;">​</a></h1><p>Node 是基于 chrome V8 的 js 运行环境 <a href="https://nodejs.org/en/download" target="_blank" rel="noreferrer">node 官网</a></p><p>在命令行工具输入 node -v 后回车可查看 node 环境是否安装成功</p><p>js 是基于 ECMAScript 语法的，操作 BOM 和 DOM</p><p>node.js 也是基于 ECMAScript 语法，还有额外的 Node API</p><p>node.js 内部的变量和方法默认不能被外部访问，如果 a.js 内部的方法要被外部(b.js)访问使用：</p><p>1、在 a 内使用 <code>exports.变量=变量</code> 或者在 a 内使用 <code>module.exports.变量=变量</code></p><p>如果同时使用 <code>exports</code> 和 <code>module.exports</code> 变量，以 <code>module.exports</code> 为准</p><p>2、在 b 内使用 <code>require(&#39;文件名&#39;)</code>访问 <code>const a = require(&#39;a&#39;)</code></p><h2 id="node-基础模块" tabindex="-1">Node 基础模块 <a class="header-anchor" href="#node-基础模块" aria-label="Permalink to &quot;Node 基础模块&quot;">​</a></h2><h3 id="fs-方法" tabindex="-1">fs 方法 <a class="header-anchor" href="#fs-方法" aria-label="Permalink to &quot;fs 方法&quot;">​</a></h3><p>f：即 file 文件 s：即 system 系统</p><p>./代表本级目录 ../代表下级目录</p><p>读取文件 <code>fs.readFile(&#39;文件路径&#39;，&#39;文件编码&#39;，回调函数)</code></p><p>文件引用 <code>const fs = require(&#39;fs&#39;)</code>；</p><p>回调函数内包含两个参数(err，doc)</p><p>err 代表是否出错，返回 null 代表没有出错，doc 为文件内容</p><p>写入文件 <code>fs.weiteFile(&#39;要写入的文件名&#39;，&#39;要写入的内容&#39;，回调函数)</code></p><p>如果有则增加内容 如果没有要写入的文件系统会自动创建</p><h3 id="path-方法" tabindex="-1">path 方法 <a class="header-anchor" href="#path-方法" aria-label="Permalink to &quot;path 方法&quot;">​</a></h3><p>window 的路径基本使用<code>/</code> <code>\\</code></p><p>但服务器 linux 只有<code>/</code></p><p>用户上传头像等是保存到服务器中，所以需要路径拼接</p><p>导入 path 模块</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> path</span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;path&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> fin </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> path.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;a&#39;</span><span style="color:#24292E;">，</span><span style="color:#032F62;">&#39;b&#39;</span><span style="color:#24292E;">，</span><span style="color:#032F62;">&#39;c.css&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 结果为 a\\b\\c.css</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在大多数情况下都会使用绝对路径</p><p>使用<code>--dirname</code> 可以获取绝对路径 <code>path.join(__dirname, &#39;路径&#39;)</code></p><h3 id="第三方模块" tabindex="-1">第三方模块 <a class="header-anchor" href="#第三方模块" aria-label="Permalink to &quot;第三方模块&quot;">​</a></h3><p>多个文件组成的包 npmjs.com 有文档</p><p>部分第三方模块可以链式编写，即 <code>res.status().send()</code></p><p>获取第三方模块，使用 <code>npm(node packge manager)</code>命令</p><p>下载：<code>npm install 模块名称</code>(下载到命令行所在目录)</p><p>卸载：<code>npm uninstall 模块名称</code></p><p>nodemon 是一个第三方辅助执行文件(文件被修改会自动执行)</p><p>1、npm install nodemon -g(-g 代表全局安装)</p><p>2、使用 nodemon 代替 node 执行</p><p>3、ctrl+c 结束命令</p><h4 id="gulp" tabindex="-1">gulp <a class="header-anchor" href="#gulp" aria-label="Permalink to &quot;gulp&quot;">​</a></h4><p>第三方模块前端构建工具</p><p>项目上线，html、js、css 合并</p><p>语法转换</p><p>公共文件抽离</p><p>1、npm install gulp</p><p>2、在项目根目录建立 gulpfile.js 文件</p><p>3、创建两个文件夹，src 文件夹放置源代码，dist 文件夹放置压缩后的文件</p><p>4、在 gulpfile.js 内编写任务</p><p>5、执行 gulpfile.js</p><p>gulp 中的方法(用<code>*</code>可以获取所有同类型文件)</p><p><code>gulp.src()</code>；获取要处理的文件</p><p><code>gulp.dest()</code>输出文件</p><p><code>gulp.task()</code>建立 gulp 任务</p><p><code>gulp.watch()</code>监控文件变化</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> gulp</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;gulp&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">gulp.</span><span style="color:#6F42C1;">task</span><span style="color:#24292E;">(first, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  gulp.</span><span style="color:#6F42C1;">src</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./src/css&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">pipe</span><span style="color:#24292E;">(gulp.</span><span style="color:#6F42C1;">dest</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;dist/css&#39;</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>gulp 插件</p><p><code>gulp-htmlmin</code> 压缩 html 文件中的代码</p><p><code>gulp-csso</code> 压缩 css</p><p><code>gulp-babel</code> js 语法转化</p><p><code>gulp-less</code> less 语法转化</p><p><code>gulp-uglify</code> 压缩混淆 js</p><p><code>gulp-file-include</code> 公共文件包含</p><p>一般网站头部和尾部会用到，使用<code>@@include(&#39;公共路径&#39;)</code>可以引用</p><p>gulp 可以将所有任务封装起来依次执行 eg:<code>gulp.task(&#39;default&#39;,[&#39;htmlmin&#39;,&#39;cssmin&#39;,&#39;copy&#39;])</code></p><h4 id="package-json" tabindex="-1">package.json <a class="header-anchor" href="#package-json" aria-label="Permalink to &quot;package.json&quot;">​</a></h4><p><code>package.json</code> 会记录项目相关信息，包括第三方模块(在 dependencies 字段中)</p><p>快速生成 <code>package.json</code> 文件可以使用 <code>npm install -y</code></p><p>在传输时可避免传递 <code>node-modules</code> 模块(本模块过大)，使用 <code>npm install</code> 即可下载所有第三模块</p><p>开发依赖</p><p>项目在开发阶段的依赖称为开发依赖，但有些项目依赖在上线之后不需要了，所以在安装包时，在开发阶段需要的依赖以--save-dev 命令结尾，此文件会存储在 <code>devDependencies</code> 中，如果在服务器线上环境使用--production</p><h3 id="服务器端" tabindex="-1">服务器端 <a class="header-anchor" href="#服务器端" aria-label="Permalink to &quot;服务器端&quot;">​</a></h3><p><code>url</code> 传输协议://IP 或域名：端口(默认为 80)/资源所在位置</p><p><code>http</code> 超文本传输协议</p><p>请求报文</p><p><code>post</code> 发送数据(安全，放在请求体中)</p><p><code>get</code> 请求数据(不安全，通过 url 传递)</p><p><code>req.headers</code> 获取请求报文信息</p><p><code>req.url</code> 获取请求地址</p><p><code>req.method</code> 获取请求方法</p><p><code>res.writeHead(状态码，{&#39;content-type&#39;：文件类型})</code> 可以设置 http 状态码和默认编码方式</p><p><code>url.parse(req.url，true)</code>会解析 url 的参数(限于 get 请求)</p><p><code>url.parse().pathname</code> 可以返回无参数的 url</p><p><code>querystring</code> 可以处理 post 请求的字符串</p><h3 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h3><p>请求什么响应什么，网页的访问路径</p><p>同步 api 从上到下执行，异步 api 会放在栈堆中，等到触发才执行</p><p>异步 api 需要通过回调函数来调用，没有返回值，所以需要封装 <code>callback</code> 函数</p><p>读取文件是异步 API，第二部是回调函数</p><p>回调异步解决的方法：将回调函数写入回调函数中，但会导致过多嵌套，还可以使用 promise 构造函数</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> promise </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">,</span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  fs.</span><span style="color:#6F42C1;">readFile</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./1.txt&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;utf8&#39;</span><span style="color:#24292E;">,(</span><span style="color:#E36209;">err</span><span style="color:#24292E;"> ,</span><span style="color:#E36209;">result</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">    if</span><span style="color:#24292E;">(err </span><span style="color:#D73A49;">!==</span><span style="color:#005CC5;"> null</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">  ​   </span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(err)</span></span>
<span class="line"><span style="color:#24292E;">    }</span><span style="color:#D73A49;">else</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#6F42C1;">      resolve</span><span style="color:#24292E;">(result</span></span>
<span class="line"><span style="color:#24292E;">    )}</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">promise.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">result</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(result);</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">((</span><span style="color:#E36209;">err</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err)</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>如果成功调用 resolve，失败调用 reject</p><p>es7 新增异步函数</p><p>在普通函数前加 async 关键字，默认返回 promise</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">anync </span><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> fn</span><span style="color:#24292E;"> (){</span></span>
<span class="line"><span style="color:#D73A49;">  throw</span><span style="color:#032F62;">&quot;发生了一些错误&quot;</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#005CC5;"> 123</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">data</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">​  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(data)</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">err</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">​  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err)</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>throw</code> 抛出异常，使用 <code>catch</code> 接收，<code>throw </code>后的代码不执行</p><p><code>async</code> 内部有 <code>await</code> 方法，可以暂停函数的执行，只有有返回值才执行</p><p><code>promisify</code> 方法可以改造异步方法比如 fs 方法，返回一个 <code>prominse</code> 对象</p><p>在调用 <code>Promisify</code> 方法</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> promisify</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;util&#39;</span><span style="color:#24292E;">).promisify</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> readFile</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> promisify</span><span style="color:#24292E;">(fs.readFile)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在浏览器中去全局对象是 window，在 node 中全局对象是 gobal</p><h3 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h3><p>网站的数据是存储在数据库中</p><p>mongoDB 基于 JSON</p><p>mysql 用于 PHP</p><p>第三方模块 mongooes</p><p>需要启动 <code>MongoDB net stat MongoDB</code></p><h3 id="express-框架" tabindex="-1">EXPRESS 框架 <a class="header-anchor" href="#express-框架" aria-label="Permalink to &quot;EXPRESS 框架&quot;">​</a></h3><p>使用 <code>npm install express</code> 命令进行下载</p><p>框架特性</p><p>提供了简洁的路由定义</p><p>对获取 http 请求参数进行简化处理</p><p>对模板引擎支持程度高，方便渲染 html</p><p>提供了中间件机制有效控制 http 请求</p><p>拥有大量第三方中间件对功能进行扩展</p><h3 id="中间件" tabindex="-1">中间件 <a class="header-anchor" href="#中间件" aria-label="Permalink to &quot;中间件&quot;">​</a></h3><p>中间件就是一堆方法，可以接收客户端发来的请求，也可以对请求做出响应，也可以将请求交给下一个中间件处理</p><p>中间件由中间件方法(由框架提供)，请求处理函数(开发人员提供)</p><p>可以针对同一个请求设置多个中间件</p><p>中间件默认从上到下匹配，匹配成功就终止匹配，可以使用 <code>next</code> 方法将请求的控制权交给下一个中间件</p><p>中间件常用来做登录保护，没有登录就不调用 <code>next</code> 方法</p><p>还可以在网站维护时设置中间件，拦截所有路由</p><p>可以自定义 404 页面，在所有路由最后定义，代表上面的都没有匹配，使用 <code>res.status</code> 设置状态码</p>`,120)]))}const b=a(o,[["render",l]]);export{u as __pageData,b as default};
